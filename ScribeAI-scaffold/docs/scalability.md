
## Long-session scalability (200 words)

Handling hour-long meeting recordings reliably requires combining client-side chunking, memory-efficient server buffering, and resumable storage. Chunking the audio client-side into fixed-duration segments (e.g., 20–30s) prevents the browser's memory from ballooning and enables progressive upload. The Socket.io server should treat chunks as append-only objects and immediately persist them to ephemeral storage (local temp files, S3 multipart uploads, or a file-backed queue) so large sessions do not remain solely in memory. For live transcription, forward chunks to the streaming transcription API (Gemini) in an ordered stream; if the network drops, the client should resume by retransmitting the newest sequence numbers. Use sequence numbers, timestamps, and chunk checksums to detect loss or duplication. For multi-tenant scaling, shard sessions across worker processes or Kubernetes pods and use a shared object store (e.g., S3) for chunk persistence; coordinate with Redis for locks and session metadata. Backpressure handling is crucial—monitor socket send buffers and pause MediaRecorder temporarily if the server cannot keep up. Finally, favor idempotent chunk processing and include a cleanup policy (expire incomplete sessions) to avoid storage leaks. These measures balance low-latency UI updates with robust handling of long durations and failures.
